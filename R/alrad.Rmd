---
title: "ALRAD Spectra"
author: "Dotto, 2016"
---

```{r Packages}
install.packages(c("gWidgetsRGtk2","prospectr","pls","clusterSim","ggplot2","Rmisc","caret","e1071","kernlab","elmNN","randomForest","devtools"))
```

```{r Load}
library(gWidgetsRGtk2) # GUI
library(prospectr)     # Preprocessing
library(pls)           # MSC 
library(clusterSim)    # Normalization
library(devtools)      # Create package
library(ggplot2)       # Plot
library(Rmisc)         # Multiplot
library(caret)         # Models
library(kernlab)       # SVM
library(e1071)         # SVM
library(elmNN)         # ANN
library(randomForest)  # RF

```

```{r ALRAD Spectra}

AlradSpectra <- function() {

###################################################
### Auxiliar functions
###################################################
fclear       <- function(...)       {gconfirm("Clear ALRAD Spectra?", title="Clear", icon="warning", parent=window,
                                              handler=function(h, ...) {svalue(file.browse)   <- ""
                                                                        svalue(file.sep)      <- ","
                                                                        svalue(spc.start.col) <- ""
                                                                        svalue(spc.end.col)   <- ""
                                                                        svalue(spc.first)     <- ""
                                                                        svalue(spc.last)      <- ""
                                                                        svalue(soil.var.col)  <- ""
                                                                        svalue(notebook)      <- 1
                                                                        enabled(pp) = FALSE
                                                                        enabled(models) = FALSE
                                                                        enabled(mdl) = FALSE
                                                                        rm(list=setdiff(ls(envir=.GlobalEnv), "AlradSpectra"), envir=.GlobalEnv)
                                                                        }
                                              )
                                     }

fquit        <- function(...)        gconfirm("Are you sure?", icon="warning", parent=window, handler=dispose(window))
fconfirmquit <- function(h, ...)    {sure <- gconfirm("Are you sure?", parent=h$obj)
                                     if(as.logical(sure))
                                       return(FALSE) #close
                                     else
                                       return(TRUE)}  #don't close
fabout       <- function(...)       {aboutwin <- gwindow("About ALRAD Spectra",width=500, height=500, parent = window)
                                     lyt.about <- glayout(cont = aboutwin, expand = F)
                                     lyt.about[1,1]   <- "ALRAD Spectra was developed by researchers at Federal University of Santa Maria. \nALRAD's name is based on the initials of its five authors: \nAndre \nLuis \nRicardo \nAlexandre \nDiego"}
fbrowse      <- function(...)        svalue(file.browse) <- gfile("Open File", type="open",
                                                           filter=c("Comma Separated Values (.csv)"="csv"))
fwarning     <- function(w)         {dispose(alert)
                                     gmessage(message = w$message, title = "Warning", icon="warning", parent = window)
                                     stop()}
ferror       <- function(e)         {dispose(alert)
                                     gmessage(message = e$message, title = "Error", icon="error", parent = window)
                                     stop()}
fimport      <- function(...)       {alert <<- galert("Wait...", title = "Importing File", delay=10000, parent=notebook)
                                     tryCatch(
                                     {alldata <<- read.table(file = svalue(file.browse),
                                                             header = as.logical(svalue(file.header)),
                                                             sep = svalue(file.sep))
                                     spectra.start.column <<- as.numeric(svalue(spc.start.col))
                                     spectra.end.column   <<- as.numeric(svalue(spc.end.col))
                                     spectra.start.number <<- as.numeric(svalue(spc.first))
                                     spectra.end.number   <<- as.numeric(svalue(spc.last))
                                     soil.var.column      <<- as.numeric(svalue(soil.var.col))
                                     soil.var.name        <<- colnames(alldata[soil.var.column])
                                     fonlyspectra()
                                     dataset              <<- c("Raw")
                                     select.dataset[]     <- dataset
                                     svalue(select.dataset) <- "Raw"
                                     },
                                     warning = function(w) fwarning(w),
                                     error =  function(e) ferror(e)
                                     )
                                     enabled(pp) = TRUE
                                     enabled(models) = TRUE
                                     dispose(alert)
                                     gmessage(message = "Import successful!", title = "File import", parent = window)
                                     }
fonlyspectra <- function(...)       {spc <- alldata[,spectra.start.column:spectra.end.column]
                                     colnames(spc) <- c(spectra.start.number:spectra.end.number)
                                     Raw <<- spc
                                     }
fview        <- function(...)        gtable(alldata, cont = gwindow("View data", width = 800, height = 200, parent = window))
fplot        <- function(h, ylab="Reflectance", ...) {plotwin <- gwindow("Plot", width = 800, height = 600, parent = window)
                                     wingroup <- ggroup(horizontal=FALSE, cont=plotwin)
                                     ggraphics(cont = wingroup, no_popup=TRUE)
                                     Sys.sleep(1)
                                     gbutton("Save plot", cont=wingroup, handler = function(...) fsaveplot(800, 600))
                                     matplot(colnames(h), t(h), xlim = c(spectra.start.number,spectra.end.number),
                                             type = "l", 
                                             xlab = "Wavelength (nm)", 
                                             ylab = ylab)
                                     }
fsaveplot    <- function(w, h,...)  {fname <- paste0(gfile("Save File", type="save", container=window,
                                                           filter=c("Portable Network Graphics (.png)"="png")),".png")
                                     dev.copy(png, fname, width=w, height=h, res=100, antialias = "cleartype")
                                     dev.off()
                                     }
fsavedata    <- function(h, ...)    {fname <- paste0(gfile("Save File", type="save",
                                                           filter=c("Comma Separated Values (.csv)"="csv")),".csv")
                                     write.csv(h, row.names = FALSE, file = fname)
                                     }
faddtolist   <- function(h, ...)    {present <- is.element(h, dataset)
                                     if(present==FALSE) dataset <<- c(dataset, h)
                                     select.dataset[] <<- dataset
                                     }
fchangesplit <- function(h, ...)    {enabled(mdl) = FALSE
                                     }
### Preprocessing functions
fnrm         <- function(...) {alert <- galert("Wait...", title = "Smoothing", delay=10000, parent=notebook)
                               tryCatch(
                               {Smoothing  <<- movav(Raw, w = as.numeric(svalue(number.smooth)))
                               faddtolist("Smoothing")
                               },
                               warning = function(w) fwarning(w),
                               error =  function(e) ferror(e)
                               )
                               dispose(alert)
                               gmessage(message = "Done!", title = "Smoothing", icon = "info", parent = window)
                               }
fbin         <- function(...) {alert <- galert("Wait...", title = "Binning", delay=10000, parent=notebook)
                               tryCatch(
                               {Binning <<- binning(Raw, bin.size = as.numeric(svalue(bin.number)))
                               faddtolist("Binning")
                               },
                               warning = function(w) fwarning(w),
                               error =  function(e) ferror(e)
                               )
                               dispose(alert)
                               gmessage(message = "Done!", title = "Binning", icon = "info", parent = window)
                               }
fabs         <- function(...) {alert <- galert("Wait...", title = "Absorbance", delay=10000, parent=notebook)
                               tryCatch(
                               {Absorbance <<- log10(1/Raw)
                               faddtolist("Absorbance")
                               },
                               warning = function(w) fwarning(w),
                               error =  function(e) ferror(e)
                               )
                               dispose(alert)
                               gmessage(message = "Done!", title = "Absorbance", icon = "info", parent = window)
                               }
fdet         <- function(...) {alert <- galert("Wait...", title = "Detrend", delay=10000, parent=notebook)
                               tryCatch(
                               {Detrend <<- detrend(X = Raw, wav = as.numeric(colnames(Raw)))
                               faddtolist("Detrend")
                               },
                               warning = function(w) fwarning(w),
                               error =  function(e) ferror(e)
                               )
                               dispose(alert)
                               gmessage(message = "Done!", title = "Detrend", icon = "info", parent = window)
                               }
fcrm         <- function(...) {alert <- galert("Wait...", title = "Continuum Removal", delay=10000, parent=notebook)
                               tryCatch(
                               {ContinuumRemoval <<- continuumRemoval(X=Raw, wav = as.numeric(colnames(Raw)),
                                                                     type = "R", interpol="linear", method="division")
                               faddtolist("ContinuumRemoval")
                               },
                               warning = function(w) fwarning(w),
                               error =  function(e) ferror(e)
                               )
                               dispose(alert)
                               gmessage(message = "Done!", title = "Continuum Removal", icon = "info", parent = window)
                               }
fsgd         <- function(...) {alert <- galert("Wait...", title = "Savitzky-Golay Derivative", delay=10000, parent=notebook)
                               tryCatch(
                               {SavitzkyGolayDerivative <<- savitzkyGolay(Raw, 
                                                        p = as.numeric(svalue(sgd.poly)),
                                                        w = as.numeric(svalue(sgd.smooth)),
                                                        m = as.numeric(svalue(sgd.deriv)))
                               faddtolist("SavitzkyGolayDerivative")
                               },
                               warning = function(w) fwarning(w),
                               error =  function(e) ferror(e)
                               )
                               dispose(alert)
                               gmessage(message = "Done!", title = "Savitzky-Golay Derivative", icon = "info", parent = window)
                               }
fsnv         <- function(...) {alert <- galert("Wait...", title = "SNV", delay=10000, parent=notebook)
                               tryCatch(
                               {SNV <<- standardNormalVariate(X = Raw)
                               faddtolist("SNV")
                               },
                               warning = function(w) fwarning(w),
                               error =  function(e) ferror(e)
                               )
                               dispose(alert)
                               gmessage(message = "Done!", title = "SNV", icon = "info", parent = window)
                               }
fmsc         <- function(...) {alert <- galert("Wait...", title = "MSC", delay=10000, parent=notebook)
                               tryCatch(
                               {MSC <<- msc(as.matrix(Raw))
                               faddtolist("MSC")
                               },
                               warning = function(w) fwarning(w),
                               error =  function(e) ferror(e)
                               )
                               dispose(alert)
                               gmessage(message = "Done!", title = "MSC", icon = "info", parent = window)
                               }
fnor         <- function(...) {alert <- galert("Wait...", title = "Normalization", delay=10000, parent=notebook)
                               tryCatch(
                               {Normalization <<- data.Normalization(Raw,
                                                            type = sub(":.*$","", svalue(nor.type)),
                                                            normalization = "row")
                               faddtolist("Normalization")
                               },
                               warning = function(w) fwarning(w),
                               error =  function(e) ferror(e)
                               )
                               dispose(alert)
                               gmessage("Done!", title = "Normalization", icon = "info",  parent = window)
                               }
### Split function
fsplit       <- function(...) {set.seed(1)
                               x <- eval(parse(text = svalue(select.dataset)))
                               x <- cbind(x,alldata[soil.var.column])
                               indices <- sample(1:nrow(x), size = (svalue(split.val)/100)*nrow(x))
                               t <- x[-indices,]
                               v <- x[ indices,]
                               colnames(t) <- paste("X", colnames(t), sep = "")
                               colnames(v)   <- paste("X", colnames(v), sep = "")
                               Train <<- t
                               Val <<- v
                               last.col <<- ncol(Train)
                               form.mdl <<- as.formula(paste(colnames(Train[last.col]),"~",
                                                             paste(names(Train)[c(1:last.col-1)], collapse="+"), collapse=""))
                               enabled(mdl) = TRUE
                               gmessage(paste("Number of validation samples:\n\n", nrow(Val)), title = "Split", parent = window)
                               }
### Modeling functions
error.comp    <- function(y, yhat)   {n              <- length(y)
	                                    r              <- cor(y, yhat)
	                                    lmy            <- lm(y~yhat)
	                                    a              <- coefficients(lmy)[1]
	                                    b              <- coefficients(lmy)[2]
	                                    r2             <- summary(lmy)$r.squared[1]
	                                    bias           <- mean(yhat)-mean(y)
	                                    msd            <- sum((yhat-y)^2)/n
	                                    rmse           <- sqrt(msd)
	                                    msd.c          <- sum((yhat-bias-y)^2)/n
	                                    rmse.c         <- sqrt(msd.c)
	                                    sb             <- (mean(yhat)-mean(y))^2
	                                    nu             <- ((1-b)^2)*(var(yhat)*((n-1)/n))
	                                    lc             <- (1-r^2)*(var(y)*((n-1)/n))
	                                    rpd            <- sd(y)/rmse
	                                    q1             <- quantile(y)[2]
	                                    q3             <- quantile(y)[4]
	                                    rpiq           <- (q3-q1)/rmse
	                                    error.i        <- round(c(r2, bias, rmse,  rpd, rpiq),2)
	                                    names(error.i) <- c("R2", "Bias", "RMSE", "RPD", "RPIQ")
	                                    return(error.i)
	                                    }
fmdl.stats    <- function(t, v, ...) {t.stats.name <- paste0(deparse(substitute(t)), ".stats")
                                      v.stats.name <- paste0(deparse(substitute(v)), ".stats")
                                      assign(t.stats.name, error.comp(t[,1], t[,2]), envir = .GlobalEnv)
                                      assign(v.stats.name, error.comp(v[,1], v[,2]), envir = .GlobalEnv)
                                      results <- rbind(get(t.stats.name), get(v.stats.name))
                                      Set <- c("Training", "Validation")
                                      res.table <- cbind(Set, results)
                                      statswin <- gwindow("Model results", width=320, height=150, parent=window)
                                      stats.lyt <- glayout(horizontal=FALSE, container=statswin)
                                      stats.lyt[1,1,expand=TRUE] <- gtable(res.table, cont = stats.lyt)
                                      stats.lyt[2,1,expand=TRUE] <- gbutton("Save results", cont=stats.lyt,
                                                                            anchor=c(0,-1),
                                                                            handler=function(...) fsavedata(res.table))
                                      }
fmdl.plot.res <- function(t, v, ...) {plotwin <- gwindow("Model accuracy", width = 1000, height = 400, parent = window)
                                      wingroup <- ggroup(horizontal=FALSE, cont=plotwin)
                                      ggraphics(cont = wingroup, no_popup=TRUE)
                                      t.stats.name <- paste0(deparse(substitute(t)), ".stats")
                                      v.stats.name <- paste0(deparse(substitute(v)), ".stats")
                                      assign(t.stats.name, error.comp(t[,1], t[,2]), envir = .GlobalEnv)
                                      assign(v.stats.name, error.comp(v[,1], v[,2]), envir = .GlobalEnv)
                        train.plot <- ggplot(t, aes(x=t[,1], y=t[,2])) +
                                      geom_point(shape=19) +
                                      labs(list(title="Training set", x="Mesured", y="Predicted")) +
                                      xlim(0, max(t)) + 
                                      ylim(0, max(t)) +
                                      geom_abline(intercept = 0, slope = 1) +
                                      annotate("text", x=max(t)*0.1, y=seq(max(t)*0.9,max(t)*0.7,-max(t)*0.05),
                                               label = paste(names(get(t.stats.name)),"=",get(t.stats.name)))
                        val.plot   <- ggplot(v, aes(x=v[,1], y=v[,2])) +
                                      geom_point(shape=19) +
                                      labs(list(title="Validation set", x="Mesured", y="Predicted")) +
                                      xlim(0, max(v)) + 
                                      ylim(0, max(v)) +
                                      geom_abline(intercept = 0, slope = 1) +
                                      annotate("text", x=max(v)*0.1,
                                               y=seq(max(v)*0.9,max(v)*0.7,-max(v)*0.05),
                                               label = paste(names(get(v.stats.name)),"=",get(v.stats.name)))
                                      Sys.sleep(1)
                                      gbutton("Save plot", cont = wingroup, handler = function(...) fsaveplot(800, 400))
                                      multiplot( train.plot, val.plot, cols = 2)
                                      }
fpls.plot.imp <- function(h, ...)    {plotwin <- gwindow("Plot", width = 800, height = 600, parent=window)
                                      wingroup <- ggroup(horizontal=FALSE, cont=plotwin)
                                      ggraphics(cont = wingroup, no_popup=TRUE)
                                      Sys.sleep(1)
                                      gbutton("Save plot", cont = wingroup, handler = function(...) fsaveplot(800, 600))
                                      comp.plot <- ggplot(h) +
                                                   labs(list(x="Components", y="RMSE"))
                                      multiplot(comp.plot)
                                      }
fmdl.plot.imp <- function(h, ...)    {plotwin <- gwindow("Plot", width = 400, height = 600, parent=window)
                                      wingroup <- ggroup(horizontal=FALSE, cont=plotwin)
                                      ggraphics(cont = wingroup, no_popup=TRUE)
                                      Sys.sleep(0.5)
                                      gbutton("Save plot", cont = wingroup, handler = function(...) fsaveplot(800, 600))
                                      comp.plot <- ggplot(varImp(h),top=40)
                                      multiplot(comp.plot)
                                      }
### MLR
fmlr        <- function(...)  {alert     <- galert("Wait... \nThis may take a few minutes!", title = "MLR model", delay=10000, parent=notebook)
                              Sys.sleep(1)
                              tryCatch(
                              {form.mlr  <- as.formula(paste(colnames(Train[last.col]),"~",paste(names(Train)[c(seq(1,last.col-1,
                                                            by=svalue(mlr.band.interval)))],collapse="+"),collapse=""))
                              mlr.model <<- glm(form.mlr, data=Train)
                              mlr.step  <<- step(mlr.model, direction="both")
                              mlr.train <<- data.frame(Train[last.col], Predicted=mlr.model$fitted.values)
                              mlr.val   <<- data.frame(Val[last.col], Predicted=predict(mlr.step, newdata=Val))
                              },
                              warning = function(w) fwarning(w),
                              error =  function(e) ferror(e)
                              )
                              dispose(alert)
                              gmessage("MLR model done", title = "MLR model", parent = window)
                              }
### PLS
fpls        <- function(...) {alert       <- galert("Wait... \nThis may take a few minutes!", title = "PLSR model", delay=10000, parent=notebook)
                              Sys.sleep(1)
                              tryCatch(
                              {bootctrl.pls<- trainControl(method <- svalue(pls.resampling), 
                                                          number <- ifelse (grepl("cv", method), svalue(pls.kfold), (svalue(pls.kfold)+10)),
                                                          repeats <- ifelse (grepl("cv", method), svalue(pls.folds), number))
                              Grid        <- expand.grid(.ncomp = seq(1,svalue(pls.comp), 1))
                              pls.test    <<- train(form.mdl, data = Train, method = 'pls', trControl = bootctrl.pls, tuneGrid = Grid)
                              pls.model   <<- plsr(form.mdl, data = Train, ncomp = pls.test$bestTune$ncomp)
                              t.pred      <- data.frame(pls.model$fitted.values)
                              v.pred      <- data.frame(predict(pls.model, newdata=Val))
                              pls.train   <<- data.frame(Train[last.col], Predicted=t.pred[,ncol(t.pred)])
                              pls.val     <<- data.frame(Val[last.col], Predicted=v.pred[,ncol(v.pred)])
                              },
                              warning = function(w) fwarning(w),
                              error =  function(e) ferror(e)
                              )
                              dispose(alert)
                              gmessage("PLSR model done", title = "PLSR model", parent = window)
                              }
### SVM
fsvm        <- function(...) {alert        <-  galert("Wait... \nThis may take a few minutes! ", title = "SVM model", delay=10000, parent=notebook)
                              Sys.sleep(1)
                              tryCatch(
                              {bootctrl.svm <<-  trainControl(method <- svalue(svm.resampling))
                              if (svalue(svm.kernel, index=TRUE)==1) fsvmlinear()
                              if (svalue(svm.kernel, index=TRUE)==2) fsvmradial()
                              svm.train    <<- data.frame(Train[last.col], Predicted=svm.model$fitted)
                              svm.val      <<- data.frame(Val[last.col], Predicted=predict(svm.model, newdata=Val))
                              },
                              warning = function(w) fwarning(w),
                              error =  function(e) ferror(e)
                              )
                              dispose(alert)
                              gmessage("SVM model done", title = "SVM model", parent = window)
                              }
fsvmlinear  <- function(...) {Grid        <-  expand.grid(.C = seq(1,16,5))
                             svm.test    <<- train(form.mdl, data = Train, method = "svmLinear",
                                             trControl = bootctrl.svm, tuneGrid = Grid)
                             svm.model   <<- svm(form.mdl, data=Train, kernel="linear", type ="eps",
                                             cost=svm.test$bestTune$C)
                             }
fsvmradial  <- function(...) {Grid        <-  expand.grid(.sigma = seq(0.000001,0.1,0.01), .C = seq(1,16,5))
                             svm.test    <<- train(form.mdl, data = Train, method = "svmRadial",
                                             trControl = bootctrl.svm, tuneGrid = Grid)
                             svm.model   <<- svm(form.mdl, data=Train, kernel="radial", type ="eps",
                                             gamma=svm.test$bestTune$sigma, cost=svm.test$bestTune$C)
                             }
### RF
frf         <- function(...) {alert       <- galert("Wait... \nThis may take a few minutes! ", title = "RF model", delay=10000, parent=notebook)
                              Sys.sleep(.5)
                              tryCatch(
                              {bootControl <- trainControl(method <- svalue(rf.resampling))
                              Grid        <- expand.grid(.mtry = seq(svalue(rf.mtry)/5,svalue(rf.mtry),svalue(rf.mtry)/5))
                              rf.test     <<- train(form.mdl, data = Train, method = 'rf', trControl = bootControl, tuneGrid = Grid,
                                                    importance = TRUE)
                              rf.model    <<- randomForest(form.mdl, data=Train, mtry=rf.test$bestTune$mtry, ntree = as.numeric(svalue(rf.ntree)))
                              rf.train    <<- data.frame(Train[last.col], Predicted=rf.model$predicted)
                              rf.val      <<- data.frame(Val[last.col], Predicted=predict(rf.model, newdata=Val))
                              },
                              warning = function(w) fwarning(w),
                              error =  function(e) ferror(e)
                              )
                              dispose(alert)
                              gmessage("RF model done", title = "RF model", parent = window)
                              }
### ANN
fann         <- function(...) {alert       <- galert("Wait... \nThis may take a few minutes! ", title = "ANN model", delay=10000, parent=notebook)
                               Sys.sleep(.5)
                               tryCatch(
                              {bootControl  <- trainControl(method= svalue(ann.resampling))
                               Grid         <- expand.grid(.nhid= seq(1,svalue(ann.hid),ceiling(svalue(ann.hid)/10)),
                                                           .actfun= c("sin", "radbas", "purelin", "tansig"))
                               ann.test     <- train(form.mdl, data = Train, method = 'elm', trControl = bootControl, tuneGrid =Grid)
                               ann.model    <- elmtrain(form.mdl, data=Train, nhid=ann.test$bestTune$nhid, actfun= ann.test$bestTune$actfun)
                               ann.train    <<- data.frame(Train[last.col], Predicted=ann.model$fitted.values)
                               ann.val      <<- data.frame(Val[last.col], Predicted=predict(ann.model, newdata=Val))
                               },
                               warning = function(w) fwarning(w),
                               error =  function(e) ferror(e)
                               )
                               dispose(alert)
                               gmessage("ANN model done", title = "ANN model", parent = window)
                               }
### KBML
fkbml        <- function(...) {alert       <-  galert("Wait... \nThis may take a few minutes! ", title = "KBML model", delay=10000, parent=notebook)
                               Sys.sleep(1) 
                               tryCatch(
                              {bootctrl.kbml<<-  trainControl(method <- svalue(kbml.resampling))
                               if (svalue(kbml.kernel, index=TRUE)==1) fkbmllinear()
                               if (svalue(kbml.kernel, index=TRUE)==2) fkbmlradial()
                               kbml.train   <<- data.frame(Train[last.col], Predicted=predict(kbml.model, newdata=Train))
                               kbml.val     <<- data.frame(Val[last.col], Predicted=predict(kbml.model, newdata=Val))
                               },
                               warning = function(w) fwarning(w),
                               error =  function(e) ferror(e)
                               )
                               dispose(alert)
                               gmessage("KBML model done", title = "KBML model", parent = window)
                               }
fkbmllinear  <- function(...) {kbml.test    <<- train(form.mdl, data = Train, method = 'gaussprLinear',trControl = bootctrl.kbml)
                               kbml.model    <<- gausspr(form.mdl, data=Train, kernel= "vanilladot", type = "regression",kpar="automatic", 
                                                        variance.model = T, var=as.numeric(svalue(kbml.var)), cross= svalue(kbml.cross))
                               }
fkbmlradial  <- function(...) {Grid          <- expand.grid(.sigma = seq(.00001,.1,.005))
                               kbml.test    <<- train(form.mdl, data = Train, method = 'gaussprRadial',
                                                trControl = bootctrl.kbml, tuneGrid = Grid)
                               kbml.model   <<- gausspr(form.mdl, data=Train, kernel="rbfdot", type ="regression",
                                                        kpar="sigma", variance.model = T,
                                                        var=svalue(kbml.var), cross= svalue(kbml.cross))
                               }

###################################################
### Vectors
###################################################
sgpolynomial         <- c(1:12)
sgderivarive         <- c(1:4)
splitnumbers         <- seq(from = 5, to = 50, by = 5)
normalization.types  <- c("n1: standardization ((x-mean)/sd)",
                          "n5: normalization in range <-1,1> ((x-mean)/max(abs(x-mean)))",
                          "n6: quotient transformation (x/mean)",
                          "n12: normalization ((x-mean)/sqrt(sum((x-mean)^2)))",
                          "n13: normalization with zero being the central point ((x-midrange)/(range/2))")
train.ctrl.method    <- c("boot", "cv", "LOOCV", "LGOCV", "repeatedcv", "timeslice")
train.ctrl.method.rf <- c("boot", "cv", "LOOCV", "LGOCV", "repeatedcv", "timeslice", "oob")
kernel.param.svm     <- c("Support Vector Machines with Linear Kernel",
                          "Support Vector Machines with Radial Basis Function Kernel")
actf                 <- c("radial basis","sigmoid","sine","hard-limit","symmetric hard-limit",
                          "satlins","tan-sigmoid","triangular basis", "positive linear", "linear")
kernel.param.kbml    <- c("Linear kernel function", "Radial Basis kernel function")
kbml.param.var       <- c(.0001,.001,.01,.1,1,10,100)

###################################################
### Main window
###################################################
window        <- gwindow("ALRAD Spectra", visible=F, width = 600,height = 600)
addHandlerUnrealize(window, handler = fconfirmquit) #confirm closing
### Start Menu
action.list   <- list(clear =  gaction(label = "Clear",  icon = "clear",  handler = fclear),
                      quit = gaction(label = "Quit", icon = "quit",  handler = fquit),
                      about = gaction(label = "About", icon = "about",  handler = fabout))
toolbar.list  <- c(action.list[c("clear")], sep = gseparator(), action.list["quit"], 
                   sep = gseparator(), action.list["about"] )
toolbar       <- gtoolbar(toolbar.list, cont = window)

###################################################
### Import data
###################################################
notebook       <- gnotebook(cont = window)
import         <- ggroup(cont = notebook, horizontal = F, label = gettext("      IMPORT DATA      "))
### Browse file
frame.imp      <- gframe("File path:", cont = import, horizontal=T)
file.browse    <- gedit(text = "", cont = frame.imp, width = 100)
browse.button  <- gbutton("Browse", cont = frame.imp, handler = fbrowse)
### Parameters
frame.file.arg <- gframe("Parameters:", cont = import, horizontal=TRUE)
                 lyt.file.arg                      <- glayout(cont = frame.file.arg, expand = F)
                 lyt.file.arg[1,1,anchor=c(-1,-1)] <- "Header"
file.header   <- lyt.file.arg[2,1,anchor=c(0,0)]   <- gradio(c("TRUE", "FALSE"), cont = lyt.file.arg)
                 lyt.file.arg[1,2,anchor=c(-1,-1)] <- "Separator"
file.sep      <- lyt.file.arg[2,2,anchor=c(1,1)]   <- gedit(text = ",", cont = lyt.file.arg, width = 1)
                 lyt.file.arg[1,3,anchor=c(1,0)]   <- "Spectral data \nstarts at column:"
spc.start.col <- lyt.file.arg[2,3,anchor=c(0,0)]   <- gedit(text = "11", cont = lyt.file.arg, width = 2)
                 lyt.file.arg[1,4,anchor=c(1,0)]   <- "Spectral data \nfinishes at column:"
spc.end.col   <- lyt.file.arg[2,4,anchor=c(0,0)]   <- gedit(text = "2161", cont = lyt.file.arg, width = 4)
                 lyt.file.arg[1,5,anchor=c(1,0)]   <- "Starting number \nof spectrum:"
spc.first     <- lyt.file.arg[2,5,anchor=c(0,0)]   <- gedit(text = "350", cont = lyt.file.arg, width = 4)
                 lyt.file.arg[1,6,anchor=c(1,0)]   <- "Finishing number \nof spectrum:"
spc.last      <- lyt.file.arg[2,6,anchor=c(0,0)]   <- gedit(text = "2500", cont = lyt.file.arg, width = 4)
                 lyt.file.arg[1,7,anchor=c(1,0)]   <- "Soil variable \nis at column:"
soil.var.col  <- lyt.file.arg[2,7,anchor=c(0,0)]   <- gedit(text = "7", cont = lyt.file.arg, width = 4)
### Import
gbutton("Import file", cont = import, handler = fimport)
### View data
gbutton("View data", cont = import, handler = fview)
### Plot raw data
gbutton("Plot raw spectra", cont = import, handler = function(...) fplot(Raw))

###################################################
### Preprocessing
###################################################
pp  <- gnotebook(cont = notebook, label = gettext(" SPECTRAL PREPROCESSING"),horizontal = F, width = 30)
       enabled(pp) = FALSE
nrm <- ggroup(cont = pp, horizontal = F,label = gettext(" Smoothing "))
bin <- ggroup(cont = pp, horizontal = F,label = gettext(" Binning "))
abs <- ggroup(cont = pp, horizontal = F,label = gettext(" Absorbance "))
det <- ggroup(cont = pp, horizontal = F,label = gettext("  Detrend  "))
crm <- ggroup(cont = pp, horizontal = F,label = gettext("Continuum Removal"))
sgd <- ggroup(cont = pp, horizontal = F,label = gettext("   SGD   "))
snv <- ggroup(cont = pp, horizontal = F,label = gettext("   SNV   "))
msc <- ggroup(cont = pp, horizontal = F,label = gettext("   MSC   "))
nor <- ggroup(cont = pp, horizontal = F,label = gettext("Normalization"))

### Smoothing
frame.desc.nrm     <- gframe("Description:", cont = nrm, horizontal = T)
lyt.desc.nrm       <- glayout(cont = frame.desc.nrm , expand = TRUE)
lyt.desc.nrm[1,1]  <- "A simple moving average of spectral data using a convolution function. Package: prospectr"
frame.param.nrm    <- gframe("Parameters:", cont = nrm, horizontal=T)
lyt.param.nrm      <- glayout(cont = frame.param.nrm, expand = TRUE)
lyt.param.nrm[1,1] <- "Number of smoothing points"
number.smooth      <- lyt.param.nrm[2,1] <- gspinbutton(from = 5, to = 101, by = 2, cont = lyt.param.nrm)
                      gbutton("Run", cont = nrm, handler = fnrm)
                      gbutton("Plot Spectra", cont = nrm, handler = function(...) fplot(Smoothing))
                      gbutton("Save to file", cont = nrm, handler = function(...) fsavedata(Smoothing))

### Binning
frame.desc.bin     <- gframe("Description:", cont = bin, horizontal = T)
lyt.desc.bin       <- glayout(cont = frame.desc.bin , expand = TRUE)
lyt.desc.bin[1,1]  <- "Signal binning. Package: prospectr"
frame.param.bin    <- gframe("Parameters:", cont = bin, horizontal=T)
lyt.param.bin      <- glayout(cont = frame.param.bin, expand = TRUE)
lyt.param.bin[1,1] <- "Bin size"
bin.number         <- lyt.param.bin[2,1:4] <- gspinbutton(from = 2, to = 100, by = 1, cont = lyt.param.bin)
                      gbutton("Run", cont = bin, handler = fbin)
                      gbutton("Plot Spectra", cont = bin, handler = function(...) fplot(Binning))
                      gbutton("Save to file", cont = bin, handler = function(...) fsavedata(Binning))

### Absorbance
frame.desc.abs     <- gframe("Description:", cont = abs, horizontal=T)
lyt.desc.abs       <- glayout(cont = frame.desc.abs, expand = TRUE)
lyt.desc.abs[1,1]  <- "Transforms reflectance to absorbance values (log10(1/R))."
                      gbutton("Run", cont = abs, handler = fabs)
                      gbutton("Plot Spectra", cont = abs, handler = function(...) fplot(Absorbance, ylab="Absorbance"))
                      gbutton("Save to file", cont = abs, handler = function(...) fsavedata(Absorbance))
                      
### Detrend
frame.desc.det     <- gframe("Description:", cont = det, horizontal=T)
lyt.desc.det       <- glayout(cont = frame.desc.det, expand = TRUE)
lyt.desc.det[1,1]  <- "Normalizes each row by applying a Standard Normal Variate transformation followed by fitting \na second order linear model and returning the fitted residuals. Package: prospectr"
                      gbutton("Run", cont = det, handler = fdet)
                      gbutton("Plot Spectra", cont = det, handler = function(...) fplot(Detrend))
                      gbutton("Save to file", cont = det, handler = function(...) fsavedata(Detrend))
                      
### Continuum Removal
frame.desc.crm     <- gframe("Description:", cont = crm, horizontal=T)
lyt.desc.crm       <- glayout(cont = frame.desc.crm, expand = TRUE)
lyt.desc.crm[1,1]  <- "The continuum removal technique was introduced by Clark and Roush (1984). \nThe algorithm find points lying on the convex hull of a spectrum, connects the points by linear interpolation and \nnormalizes the spectrum by dividing the input data by the interpolated line. Package: prospectr"
lyt.desc.crm[2,1]  <- "Data type: Reflectance"
lyt.desc.crm[3,1]  <- "Interpolation method: Linear"
lyt.desc.crm[4,1]  <- "Normalization method: Division"
                      gbutton("Run", cont = crm, handler = fcrm)
                      gbutton("Plot Spectra", cont = crm, handler = function(...) fplot(ContinuumRemoval))
                      gbutton("Save to file", cont = crm, handler = function(...) fsavedata(ContinuumRemoval))
                      
### SG Derivative
frame.desc.sgd     <- gframe("Description:",cont = sgd, horizontal = T)
lyt.desc.sgd       <- glayout(cont = frame.desc.sgd , expand = TRUE)
lyt.desc.sgd[1,1]  <- "Savitzky-Golay Derivative.\nThe Savitzky-Golay algorithm fits a local polynomial regression on the signal. It requires evenly spaced data points. Mathematically, \nit operates simply as a weighted sum over a given window. Package: prospectr"
frame.param.sgd    <- gframe("Parameters:", cont = sgd, horizontal=T)
lyt.param.sgd      <- glayout(cont = frame.param.sgd, expand = TRUE)
lyt.param.sgd[1,1] <- "Number of smoothing points"
sgd.smooth         <- lyt.param.sgd[2,1] <- gspinbutton(from = 5, to = 101, by = 2, cont = lyt.param.sgd)
lyt.param.sgd[1,2] <- "Polynomial order"
sgd.poly           <- lyt.param.sgd[2,2] <- gcombobox(sgpolynomial, cont = lyt.param.sgd)
lyt.param.sgd[1,3] <- "Derivative order"
sgd.deriv          <- lyt.param.sgd[2,3] <- gcombobox(sgderivarive, cont = lyt.param.sgd)
                      gbutton("Run", cont = sgd, handler = fsgd)
                      gbutton("Plot Spectra", cont = sgd, handler = function(...) fplot(SavitzkyGolayDerivative))
                      gbutton("Save to file", cont = sgd, handler = function(...) fsavedata(SavitzkyGolayDerivative))
                      
### SNV
frame.desc.snv     <- gframe("Description:", cont = snv, horizontal=T)
lyt.desc.snv       <- glayout(cont = frame.desc.snv, expand = TRUE)
lyt.desc.snv[1,1]  <- "Standard Normal Variate normalizes each row by substracting each row by its mean and dividing by \nits standard deviation. Package: prospectr"
                      gbutton("Run", cont = snv, handler = fsnv)
                      gbutton("Plot Spectra", cont = snv, handler = function(...) fplot(SNV))
                      gbutton("Save to file", cont = snv, handler = function(...) fsavedata(SNV))
                      
### MSC
frame.desc.msc     <- gframe("Description:", cont = msc, horizontal=T)
lyt.desc.msc       <- glayout(cont = frame.desc.msc, expand = TRUE)
lyt.desc.msc[1,1]  <- "Performs multiplicative scatter/signal correction on spectral data. Package: pls"
                      gbutton("Run", cont = msc, handler = fmsc)
                      gbutton("Plot Spectra", cont = msc, handler = function(...) fplot(MSC))
                      gbutton("Save to file", cont = msc, handler = function(...) fsavedata(MSC))
                      
### Normalization
frame.desc.nor     <- gframe("Description:",cont = nor, horizontal = T)
lyt.desc.nor       <- glayout(cont = frame.desc.nor , expand = TRUE)
lyt.desc.nor[1,1]  <- "Different types of data normalization. Package: clusterSim"
frame.param.nor    <- gframe("Parameters:", cont = nor, horizontal=T)
lyt.param.nor      <- glayout(cont = frame.param.nor, expand = TRUE)
lyt.param.nor[1,1] <- "Type of Normalization."
nor.type           <- lyt.param.nor[2,1] <- gradio(normalization.types, checked = T, cont = lyt.param.nor)
                      gbutton("Run", cont = nor, handler = fnor)
                      gbutton("Plot Spectra", cont = nor, handler = function(...) fplot(Normalization))
                      gbutton("Save to file", cont = nor, handler = function(...) fsavedata(Normalization))
                      
###################################################
### Models
###################################################
models             <- ggroup(cont = notebook, label = gettext("           MODEL           "), horizontal = F)
                      glabel("Select input data for modeling:", cont = models, anchor = c(-1,0))
select.dataset     <- gcombobox("", cont = models, handler = fchangesplit)
                      glabel("Size of validation set (%):", cont = models, anchor = c(-1,0))
split.val          <- gcombobox(splitnumbers, cont = models, selected = 6, handler = fchangesplit)
                      gbutton("Split data", cont = models, handler = fsplit)
mdl                <- gnotebook(cont = models)
                      enabled(models) = FALSE
                      enabled(mdl) = FALSE

### MLR
mdl.mlr            <- ggroup(cont = mdl, horizontal = F,label = gettext("   MLR   "))
frame.desc.mlr     <- gframe("Description:",cont = mdl.mlr, horizontal = T)
lyt.desc.mlr       <- glayout(cont = frame.desc.mlr, expand = TRUE)
lyt.desc.mlr[1,1]  <- "Functions to perform Multiple Linear Regression (MLR). Package: stats / MASS / caret"
frame.param.mlr    <- gframe("Tuning parameters:", cont = mdl.mlr, horizontal=T)
lyt.param.mlr      <- glayout(cont = frame.param.mlr , expand = TRUE)
lyt.param.mlr[1,1] <- "Band interval"
mlr.band.interval  <- lyt.param.mlr[2,1] <- gspinbutton(from = 1, to = 30, by = 1, value = 25, cont = lyt.param.mlr)
                      gbutton("Run MLR model", cont = mdl.mlr, handler = fmlr)
                      gbutton("MLR model results", cont = mdl.mlr, handler = function(...) fmdl.stats(mlr.train, mlr.val))
                      gbutton("Plot model accuracy",cont = mdl.mlr, handler = function(...) fmdl.plot.res(mlr.train, mlr.val))
                      
### PLS
mdl.pls            <- ggroup(cont = mdl, horizontal = F,label = gettext("   PLSR   "))
frame.desc.pls     <- gframe("Description:",cont = mdl.pls, horizontal = T)
lyt.desc.pls       <- glayout(cont = frame.desc.pls, expand = TRUE)
lyt.desc.pls[1,1]  <- "Functions to perform partial least squares regression (PLSR). Package: pls / caret"
frame.param.pls    <- gframe("Tuning parameters:", cont = mdl.pls, horizontal=T)
lyt.param.pls      <- glayout(cont = frame.param.pls , expand = TRUE)
lyt.param.pls[1,1] <- "Resampling method"
pls.resampling     <- lyt.param.pls[2,1] <- gcombobox(train.ctrl.method, cont = lyt.param.pls)
                      lyt.param.pls[1,2] <- "Number of folds or number \nof resampling iterations"
pls.folds          <- lyt.param.pls[2,2] <- gspinbutton(from = 1, to = 500, by = 1, value = 5, cont = lyt.param.pls)
                      lyt.param.pls[1,3] <- "For repeated k-fold cross-validation only: \nnumber of folds to compute"
pls.kfold          <- lyt.param.pls[2,3] <- gspinbutton(from = 1, to = 500, by = 1,value =  10, cont = lyt.param.pls)
                      lyt.param.pls[1,4] <- "Number of components to \ninclude in the model"
pls.comp           <- lyt.param.pls[2,4] <- gspinbutton(from = 1, to = 500, by = 1, value =  30, cont = lyt.param.pls)
                      gbutton("Run PLSR model", cont = mdl.pls , handler = fpls)
                      gbutton("Plot variable importance", cont = mdl.pls, handler = function(...) fpls.plot.imp(pls.test))
                      gbutton("PLSR model results", cont = mdl.pls, handler = function(...) fmdl.stats(pls.train, pls.val))
                      gbutton("Plot model accuracy",cont = mdl.pls, handler = function(...) fmdl.plot.res(pls.train, pls.val))
                      
### SVM
mdl.svm            <- ggroup(cont = mdl, horizontal = F,label = gettext("    SVM    "))
frame.desc.svm     <- gframe("Description:",cont = mdl.svm, horizontal = T)
lyt.desc.svm       <- glayout(cont = frame.desc.svm, expand = TRUE)
lyt.desc.svm[1,1]  <- "Functions to perform Support Vector Machines (SVM). Package: e1071 / kernlab / caret"
frame.param.svm    <- gframe("Tuning parameters:", cont = mdl.svm, horizontal=T)
lyt.param.svm      <- glayout(cont = frame.param.svm , expand = TRUE)
lyt.param.svm[1,1] <- "Resampling method"
svm.resampling     <- lyt.param.svm[2,1] <- gcombobox(train.ctrl.method, cont = lyt.param.svm)
lyt.param.svm[1,2] <- "Kernel parameters"
svm.kernel         <- lyt.param.svm[2,2] <- gradio(kernel.param.svm, cont = lyt.param.svm)
                      gbutton("Run SVM model", cont = mdl.svm, handler = fsvm)
                      gbutton("Plot variable importance", cont = mdl.svm, handler = function(...) fmdl.plot.imp(svm.test))
                      gbutton("SVM model results", cont = mdl.svm, handler = function(...) fmdl.stats(svm.train, svm.val))
                      gbutton("Plot model accuracy",cont = mdl.svm, handler = function(...) fmdl.plot.res(svm.train, svm.val))
                      
### RF
mdl.rf             <- ggroup(cont = mdl, horizontal = F,label = gettext("    RF    "))
frame.desc.rf      <- gframe("Description:",cont = mdl.rf, horizontal = T)
lyt.desc.rf        <- glayout(cont = frame.desc.rf, expand = TRUE)
lyt.desc.rf[1,1]   <- "Functions to perform Random Forest (RF). Package: randomForest / caret"
frame.param.rf     <- gframe("Tuning parameters:", cont = mdl.rf, horizontal=T)
lyt.param.rf       <- glayout(cont = frame.param.rf , expand = TRUE)
lyt.param.rf[1,1]  <- "Resampling method"
rf.resampling      <- lyt.param.rf[2,1]  <- gcombobox(train.ctrl.method.rf, cont = lyt.param.rf)
                      lyt.param.rf[1,2]  <- "Randomly Selected Predictors \n(mtry)"
rf.mtry            <- lyt.param.rf[2,2]  <- gspinbutton(from = 50, to = 500, by = 50, value = 50, cont = lyt.param.rf)
                      lyt.param.rf[1,3]  <- "Number of Trees \n(ntree)"
rf.ntree           <- lyt.param.rf[2,3]  <- gedit(text = "500", cont = lyt.param.rf, width = 4)
                      gbutton("Run RF model", cont = mdl.rf, handler = frf)
                      gbutton("Plot variable importance", cont = mdl.rf, handler = function(...) fmdl.plot.imp(rf.test))
                      gbutton("RF model results", cont = mdl.rf, handler = function(...) fmdl.stats(rf.train, rf.val))
                      gbutton("Plot model accuracy",cont = mdl.rf, handler = function(...) fmdl.plot.res(rf.train, rf.val))
                      
### ANN
mdl.ann            <- ggroup(cont = mdl, horizontal = F,label = gettext("    ANN    "))
frame.desc.ann     <- gframe("Description:",cont = mdl.ann, horizontal = T)
lyt.desc.ann       <- glayout(cont = frame.desc.ann, expand = TRUE)
lyt.desc.ann[1,1]  <- "Functions to perform Artificial Neural Network (ANN). Package: elmNN / caret"
frame.param.ann    <- gframe("Tuning parameters:", cont = mdl.ann, horizontal=T)
lyt.param.ann      <- glayout(cont = frame.param.ann , expand = TRUE)
lyt.param.ann[1,1] <- "Resampling method"
ann.resampling     <- lyt.param.ann[2,1] <- gcombobox(train.ctrl.method, cont = lyt.param.ann)
lyt.param.ann[1,2] <- "Activation Function"
lyt.param.ann[2,2] <- gcombobox(actf, cont = lyt.param.ann)
lyt.param.ann[1,3] <- "Hidden Units"
ann.hid            <- lyt.param.ann[2,3] <- gspinbutton(from = 1, to = 50, by = 1, value = 50, cont = lyt.param.ann)
                      gbutton("Run ANN model", cont = mdl.ann, handler = fann)
                      gbutton("Plot variable importance", cont = mdl.ann, handler = function(...) fmdl.plot.imp(ann.test))
                      gbutton("ANN model results", cont = mdl.ann, handler = function(...) fmdl.stats(ann.train, ann.val))
                      gbutton("Plot model accuracy", cont = mdl.ann, handler = function(...) fmdl.plot.res(ann.train, ann.val))
                      
### KBML
mdl.kbml            <- ggroup(cont = mdl, horizontal = F,label = gettext(" KBML "))
frame.desc.kbml     <- gframe("Description:",cont = mdl.kbml, horizontal = T)
lyt.desc.kbml       <- glayout(cont = frame.desc.kbml, expand = TRUE)
lyt.desc.kbml[1,1]  <- "Functions to perform kbml. Package: arm / caret"
frame.param.kbml    <- gframe("Tuning parameters:", cont = mdl.kbml, horizontal=T)
lyt.param.kbml      <- glayout(cont = frame.param.kbml , expand = TRUE)
lyt.param.kbml[1,1] <- "Resampling method"
kbml.resampling     <- lyt.param.kbml[2,1] <- gcombobox(train.ctrl.method, cont = lyt.param.kbml)
                       lyt.param.kbml[1,2] <- "Initial noise variance"
kbml.var            <- lyt.param.kbml[2,2] <- gcombobox(kbml.param.var, selected = 2, cont = lyt.param.kbml)
                       lyt.param.kbml[1,3] <- "K-fold cross-validation" 
kbml.cross          <- lyt.param.kbml[2,3] <- gspinbutton(from = 2, to = 100, by = 1, value = 10, cont = lyt.param.kbml)
                       lyt.param.kbml[1,4] <- "Kernel parameters"
kbml.kernel         <- lyt.param.kbml[2,4] <- gradio(kernel.param.kbml, cont = lyt.param.kbml)
                       gbutton("Run KBML model", cont = mdl.kbml, handler = fkbml)
                       gbutton("Plot variable importance", cont = mdl.kbml, handler = function(...) fmdl.plot.imp(kbml.test))
                       gbutton("KBML model results", cont = mdl.kbml, handler = function(...) fmdl.stats(kbml.train, kbml.val))
                       gbutton("Plot model accuracy", cont = mdl.kbml, handler = function(...) fmdl.plot.res(kbml.train, kbml.val))
                       
### Focus on first tab
svalue(notebook)   <- 1
svalue(pp)         <- 1
svalue(mdl)        <- 1
### Window visibility
visible(window)    <- TRUE

}

AlradSpectra()


#############################################################################################################
```

